<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"
               xmlns:s="library://ns.adobe.com/flex/spark"
               xmlns:mx="library://ns.adobe.com/flex/mx"
               xmlns:comp="components.*"
               width="825" height="1028"
               creationComplete="init(event)">
    <fx:Style source="demoStyles.css"/>
    <fx:Declarations>
        <!-- Place non-visual elements (e.g., services, value objects) here -->
    </fx:Declarations>
    <fx:Script>
    <![CDATA[
        import com.pubnub.PubNub;
        import com.pubnub.PubNubSecure;

        import flashx.textLayout.elements.TextFlow;

        import mx.formatters.DateFormatter;
        import mx.utils.StringUtil;

        import spark.events.TextOperationEvent;
        import spark.utils.TextFlowUtil;

        [Bindable]

        public var p:PubNub;
        public var config:Object;
        public var CommonValues:Object;
        public var PAMValues:Object;
        private var consoleString:String;
        private var presenceString:String;
        private var historyString:String;
        private var flow:TextFlow;
        private var chromeColorStatusOff:String = "#56B6F9";
        private var chromeColorStatusOn:String = "#cd0202";
        private var SOME_UUID:String = 'some_uuid';
        private var currentHeartbeat:int;
        private var currentHeartbeatInterval:int;
        private var currentChannel:String;
        public var isSsl:Boolean;

        [Embed(source='../assets/Lock.png')]
        [Bindable]
        public var iconLock:Class;

        [Embed(source='../assets/unLock.png')]
        [Bindable]
        public var iconUnLock:Class;

        public function init(e:Event = null):void {

            Security.allowInsecureDomain("*");
            Security.allowDomain("*");
            getMessagesTextArea();

            consoleString = "";
            presenceString = "";
            historyString = "";

            channelTextInput.text = presenceChannelInput.text = "flash_channel";
            authKeyTextInput.text = 'x';
            originTextInput.text = 'presence-beta.pubnub.com';
            publishKeyTextInput.text = 'demo';
            subscribeKeyTextInput.text = 'demo';

            pamSecretKeyTextInput.text = 'demo';
            pamAuthKeyTextInput.text = 'x';
            pamChannelTextInput.text = 'flash_channel';
            pamTtlTextInput.text = '15';

            btnSSL.setStyle("icon", iconLock);
            btnSSL.setStyle("chromeColor", "#cd0202");

            miscContainer.visible = miscContainer.includeInLayout = false;
            presenceContainer.visible = presenceContainer.includeInLayout = false;

            currentHeartbeat = 10;
            currentHeartbeatInterval = 3;

            subscribe();
            channelTextInput.addEventListener(Event.CHANGE, doSubscribe);
        }

        // Additional buttons:
        public function onSetUuid(uuid:*):void {
            appendStringToConsole(uuid);
        }

        private function time():void {
            p.time(function (msg:Number):void {
                appendObjectToConsole(String(msg));
            });
        }

        private function history():void {
            p.history({
                channel: channel_val(),
                callback: function (message:Array):void {
                    historyAppendText(message[0]);
                },
                error: appendErrorToConsole
            });
        }

        private function doUUID():void {
            p.uuid(onSetUuid);
        }

        private function doGetUUID():void {
            p.get_uuid(onSetUuid);
        }

        private function hereNowHandler():void {
            p.here_now({
                channel: presenceChannelCheckbox.selected ? presenceChannelInput.text : false,
                state: presenceStateCheckbox.selected,
                uuids: presenceUUIDsCheckbox.selected ? 1 : 0,
                callback: appendObjectToConsole,
                error: appendErrorToConsole
            });
        }

        private function whereNowHandler():void {
            p.where_now({
                uuid: presenceUUIDInput.text,
                callback: appendObjectToConsole,
                error: appendErrorToConsole
            });
        }

        private function clearLogHandler():void {
            consoleLog.text = "";
            consoleString = "";
        }

        private function clearPresenceHandler():void {
            presenceArea.text = "";
            presenceString = "";
        }

        private function clearHistoryHandler():void {
            historyArea.text = "";
            historyString = "";
        }

        private function publish():void {
            p.publish({
                channel: channel_val(),
                message: { "data": messagesTextArea.text },
                auth_key: authKeyTextInput.text.split(/\s+/).join(''),
                error: appendErrorToConsole
            }, appendObjectToConsole);
        }


        private function subscribe():void {
            unsubscribe();

            var publish_key:String = publishKeyTextInput.text.split(/\s+/).join(''),
                    auth_key:String = authKeyTextInput.text.split(/\s+/).join(''),
                    cipher_key:String = StringUtil.trim(chiperKeyTextInput.text),
                    subscribe_key:String = subscribeKeyTextInput.text.split(/\s+/).join(''),
                    secret_key:String = pamSecretKeyTextInput.text.split(/\s+/).join(''),
                    origin:String = originTextInput.text.split(/\s+/).join('');

            p = (cipher_key ? PubNubSecure.init : PubNub.init)({
                publish_key: publish_key,
                auth_key: auth_key,
                ssl: isSsl,
                cipher_key: cipher_key,
                secret_key: secret_key,
                subscribe_key: subscribe_key,
                origin: origin,
                uuid: uuid_val(),
                heartbeat: currentHeartbeat,
                heartbeat_interval: currentHeartbeatInterval
            });

            connecting();

            p.subscribe({
                backfill: false,
                noheresync: true,
                channel: channel_val(),
                message: function subscribeMessageHandler(message:Object, envelope:Object, channel:String, time:Number):void {
                    appendObjectToConsole(message);
                },
                presence: function subscribePresenceHandler(message:Object, here:*, channel:String, presenceChannel:String = null):void {
                    presenceAppend(message);
                },
                connect: function subscribeConnectHandler(channel:String):void {
                    unsubscribeButton.enabled = true;
                    subscribeButton.enabled = false;
                    connected();
                    updateHeartbeatValues();
                    appendStringToConsole(channel);
                },
                disconnect: appendObjectToConsole,
                error: function subscribeErrorHandler(e:Object):void {
                    unsubscribeButton.enabled = true;
                    subscribeButton.enabled = false;
                    appendErrorToConsole(e);
                }
            });
        }

        private function unsubscribe():void {
            if (unsubscribeButton.enabled === false) {
                return;
            }
            if (!p) {
                noP('unsubscribe');
                return;
            }

            p.unsubscribe({
                channel: currentChannel,
                callback: function (message:Object):void {
                    disconnected();
                    appendObjectToConsole(message);
                    subscribeButton.enabled = true;
                    unsubscribeButton.enabled = false;
                }
            });
        }

        // PAM buttons:
        private function grant():void {
            if (!p) {
                noP('grant');
                return;
            }
            var grantConfig:Object = {
                channel: pamChannelTextInput.text.toString(),
                auth_key: pamAuthKeyTextInput.text,
                read: pamReadCheckbox.selected,
                write: pamWriteCheckbox.selected,
                ttl: parseInt(pamTtlTextInput.text),
                error: appendErrorToConsole,
                callback: appendObjectToConsole
            };

            p.grant(grantConfig);

            if (pamPnpresCheckbox.selected) {
                grantConfig.channel += '-pnpres';
                p.grant(grantConfig);
            }
        }

        private function revoke():void {
            if (!p) {
                noP('revoke');
                return;
            }

            var revokeConfig:Object = {
                channel: pamChannelTextInput.text.toString(),
                auth_key: authKeyTextInput.text,
                callback: appendObjectToConsole,
                error: appendErrorToConsole
            };

            p.revoke(revokeConfig);

            if (pamPnpresCheckbox.selected) {
                revokeConfig.channel += '-pnpres';
                p.revoke(revokeConfig);
            }
        }

        private function audit():void {
            if (!p) {
                noP('audit');
                return;
            }

            p.audit({
                channel: channel_val(),
                auth_key: authKeyTextInput.text,
                callback: appendObjectToConsole,
                error: appendErrorToConsole
            });
        }

        private function stateClickHandler(event:MouseEvent):void {
            var state:Object = {};

            if (keyField1.text && valueField1.text) {
                state[keyField1.text] = valueField1.text;
            }

            if (keyField2.text && valueField2.text) {
                state[keyField2.text] = valueField2.text;
            }

            if (keyField3.text && valueField3.text) {
                state[keyField3.text] = valueField3.text;
            }

            p.state({
                channel: presenceChannelInput.text,
                state: state,
                callback: appendObjectToConsole,
                error: appendErrorToConsole
            });
        }

        private function updateHeartbeatValues():void {
            presenceHeartbeatInput.text = p.get_heartbeat().toString();
            presenceHeartbeatIntervalInput.text = p.get_heartbeat_interval().toString();
        }

        private function setCurrentUUIDHandler():void {
            presenceUUIDInput.text = p.get_uuid();
        }

        private function setHeartbeatHandler():void {
            currentHeartbeat = parseInt(presenceHeartbeatInput.text);
            p.set_heartbeat(currentHeartbeat);
            updateHeartbeatValues();
        }

        private function setHeartbeatIntervalHandler():void {
            currentHeartbeatInterval = parseInt(presenceHeartbeatIntervalInput.text);
            p.set_heartbeat_interval(currentHeartbeatInterval);
            updateHeartbeatValues();
        }

        private function getHeartbeatHandler():void {
            presenceHeartbeatInput.text = p.get_heartbeat().toString();
        }

        private function getHeartbeatIntervalHandler():void {
            presenceHeartbeatIntervalInput.text = p.get_heartbeat_interval().toString();
        }

        private function miscToggle():void {
            miscContainer.visible = miscContainer.includeInLayout = !miscContainer.visible;
            miscTab.setStyle("chromeColor", miscContainer.visible ? chromeColorStatusOff : chromeColorStatusOn);
        }

        private function presenceToggle():void {
            presenceContainer.visible = presenceContainer.includeInLayout = !presenceContainer.visible;
            presenceTab.setStyle("chromeColor", presenceContainer.visible ? chromeColorStatusOff : chromeColorStatusOn);
        }

        // Helpers:
        private function toggleSSL():void {
            if (!isSsl) {
                btnSSL.setStyle("icon", iconUnLock);
                btnSSL.setStyle("chromeColor", chromeColorStatusOff);
                isSsl = !isSsl;
                subscribe();
            }
            else {
                isSsl = !isSsl;
                btnSSL.setStyle("icon", iconLock);
                btnSSL.setStyle("chromeColor", chromeColorStatusOn);
                subscribe();
            }
        }

        private function channel_val():String {
            if (presenceBindToSubscribeChannelCheckbox.selected) {
                presenceChannelInput.text = channelTextInput.text;
            }
            currentChannel = channelTextInput.text;
            return currentChannel;
        }

        private function uuid_val():String {
            return useDefaultUUIDCheckbox.selected ? p.uuid() : uuidInput.text;
        }

        private function channelChangedHandler():void {
            channel_val();
        }

        private function appendObjectToConsole(message:Object):void {
            var mess:String;

            mess = JSON.stringify(message)
                    .replace(/\&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/,/g, ", ");

            if (mess && mess.length > 0) {
                appendToConsole(mess, '0x71BDFF');
            }
        }

        private function appendErrorToConsole(message:Object):void {
            appendToConsole(JSON.stringify(message), '0xFF0000');
        }

        private function appendStringToConsole(message:String):void {
            appendToConsole(message, '0x71BDFF');
        }

        private function appendToConsole(message:String, color:String):void {
            try {
                flow = TextFlowUtil.importFromString(
                        (consoleString = "<p><span>" + currentDate() + '</span>: <span color="' + color + '">' +
                                message + "</span></p>\n" + consoleString)
                );
                consoleLog.textFlow = flow;
            }
            catch (error:Error) {
                appendErrorToConsole(error.message);
            }
        }

        private function presenceAppend(message:Object):void {
            try {
                flow = TextFlowUtil.importFromString(
                        (presenceString = "<p><span>" + currentDate() + '</span>: <span color="0xF7B23B">' + JSON.stringify(message) + "</span></p>\n" + presenceString)
                );
                presenceArea.textFlow = flow;
            }
            catch (error:Error) {
                appendErrorToConsole(error.message);
            }
        }

        private function historyAppendText(message:Object):void {
            try {
                flow = TextFlowUtil.importFromString(
                        (historyString = "<p>" + JSON.stringify(message) + "</p>\n")
                );
                historyArea.textFlow = flow;
            }
            catch (error:Error) {
                appendErrorToConsole(error.message);
            }
        }

        private function connected(str:String = ""):void {
            if (str != "") {
                appendStringToConsole(str);
            }
            this.subConnectionStatus.setStyle('backgroundColor', "#00FC00");
        }

        private function connecting(str:String = ""):void {
            if (str != "") {
                appendStringToConsole(str);
            }
            this.subConnectionStatus.setStyle('backgroundColor', "#FFD219");
        }

        private function disconnected(str:String = ""):void {
            if (str != "") {
                appendStringToConsole(str);
            }
            this.subConnectionStatus.setStyle('backgroundColor', "#FC0000");
        }

        private function getMessagesTextArea():void {
            messagesTextArea.text = JSON.stringify({"text": "hey"});
        }

        private function networkError(str:String):void {
            this.subConnectionStatus.setStyle('backgroundColor', "#FC0000");
            appendStringToConsole(str);
        }

        private function noP(methodName:String):void {
            appendStringToConsole(methodName + '(): instance is not initialized');
        }

        private function currentDate():String {
            var CurrentDateTime:Date = new Date();
            var CurrentDF:DateFormatter = new DateFormatter();
            CurrentDF.formatString = "YYYY/MM/DD LL:NN:SS A";
            var DateTimeString:String = CurrentDF.format(CurrentDateTime);
            return DateTimeString;
        }

        protected function doSubscribe(event:TextOperationEvent):void {
            if (currentChannel && currentChannel.length > 0) {
                unsubscribe();
            }
        }
        ]]>
	</fx:Script>
	<s:VGroup horizontalAlign="center">
	<s:BorderContainer id="topContainer" width ="100%" >
		<s:HGroup paddingTop="6" paddingBottom="6" horizontalCenter="0" verticalCenter="0">
			<s:Button id="subscribeButton" width="118" height="32" label="SUBSCRIBE"
					  chromeColor="#CD0202" click="subscribe()" color="#FCFAFA"/>
			<s:Button id="unsubscribeButton" width="118" height="32" label="UNSUBSCRIBE"
					  click="unsubscribe()" color="#F9F1F1" enabled="false"/>
			<s:Button id="btnSSL" height="32" label="SSL" chromeColor="#56B6F9"
					  click="toggleSSL()"/>
			<s:Button id="miscTab" height="32" label="MISC" click="miscToggle()"/>
			<s:Button id="presenceTab" height="32" label="PRESENCE" click="presenceToggle()"/>
		</s:HGroup>
	</s:BorderContainer>

	<s:VGroup width ="100%" horizontalAlign="center" paddingTop="6" paddingBottom="6">
		<s:BorderContainer id="miscContainer" width="100%" backgroundColor="#FDF9F9"
						   borderColor="#FEFEFE" chromeColor="#FCF9F9">
			<s:HGroup  horizontalCenter="0" verticalCenter="0">
				<s:Button x="11" y="5" label="time" click="time()"/>
				<s:Button id="UUID" x="93" y="5" label="UUID" click="doUUID()"/>
				<s:Button id="getUUID" x="175" y="5" label="getUUID" click="doGetUUID()"/>
			</s:HGroup>
		</s:BorderContainer>
		<s:BorderContainer id="presenceContainer" visible="true" bottom="6" width="100%"
						   borderColor="#FCFAFA" includeInLayout="true">
			<s:VGroup x="10" top="34" bottom="40">
				<s:HGroup>
					<s:Label text="key: "/>
					<s:TextInput id="keyField1" width="77"/>
					<s:Label text="value: "/>
					<s:TextInput id="valueField1" width="77"/>
				</s:HGroup>
				<s:HGroup>
					<s:Label text="key: "/>
					<s:TextInput id="keyField2" width="77"/>
					<s:Label text="value: "/>
					<s:TextInput id="valueField2" width="77"/>
				</s:HGroup>
				<s:HGroup>
					<s:Label text="key: "/>
					<s:TextInput id="keyField3" width="77"/>
					<s:Label text="value: "/>
					<s:TextInput id="valueField3" width="77"/>
				</s:HGroup>
			</s:VGroup>
			<s:Button id="presenceStateUpdateButton" label="Update" right="545" top="5" click="stateClickHandler(event)"/>
			<s:Label x="10" y="10" fontWeight="bold" text="State fields:"/>
            <s:TextInput id="presenceChannelInput" x="378" y="5" width="227" enabled="true"
                         prompt="channel"/>
			    <s:Button id="presenceHereNowButton" x="296" y="45" label="Here now" click="hereNowHandler()"/>

                <s:CheckBox id="presenceUUIDsCheckbox" x="499" y="47" label="uuids" selected="true"/>
                <s:CheckBox id="presenceStateCheckbox" x="559" y="46" label="state"
							selected="true"/>
				<s:CheckBox id="presenceChannelCheckbox" x="378" y="47" width="113"
							label="single channel ^" selected="true"/>
				<s:CheckBox id="presenceBindToSubscribeChannelCheckbox" x="613" y="7"
							label="Bind to subscribe channel" selected="true"/>
			<s:Button id="presenceWhereNowButton" x="296" y="89" label="Where Now" click="whereNowHandler()"/>
			<s:TextInput id="presenceUUIDInput" x="389" y="88" width="262" enabled="true"
						 prompt="uuid"/>
			<s:Label x="296" y="10" fontWeight="bold" text="Channel:"/>
			<s:Button id="presenceSetCurrentUUIDButton" x="659" y="88" label="use current UUID" click="setCurrentUUIDHandler()"/>
			<s:Label x="10" y="138" fontWeight="bold" text="Hearbeat:"/>
			<s:Label x="375" y="138" fontWeight="bold" text="Hearbeat interval:"/>
			<s:TextInput id="presenceHeartbeatIntervalInput" x="488" y="132" prompt="in seconds"/>
			<s:Button id="presenceHeartbeatIntervalGet" x="625" y="132" label="get" click="getHeartbeatIntervalHandler()"/>
			<s:Button id="presenceHeartbeatIntervalSet" x="704" y="132" label="set" click="setHeartbeatIntervalHandler()"/>
			<s:TextInput id="presenceHeartbeatInput" x="74" y="132" prompt="in seconds"/>
			<s:Button id="presenceHeartbeatGet" x="211" y="132" label="get" click="getHeartbeatHandler()"/>
			<s:Button id="presenceHeartbeatSet" x="290" y="132" label="set" click="setHeartbeatHandler()"/>
		</s:BorderContainer>
	</s:VGroup>
	
	<s:BorderContainer id="bottomContainer" width="100%" height="765" borderColor="#A7A3A3">
		<s:TextArea id="messagesTextArea" x="15" y="143" width="388" height="70" editable="true"
					enabled="true" maxChars="250"/>
		<s:Label x="17" y="229" height="19" text="Messages:"/>
		<s:Button id="clearLog" x="84" y="227" height="15" label="Clear" click="clearLogHandler()"/>
		<s:Button x="331" y="191" label="Publish" click="publish()"/>
		<s:TextInput id="originTextInput" x="119" y="36"/>
		<s:TextInput id="subscribeKeyTextInput" x="420" y="39" width="314"/>
		<s:TextInput id="channelTextInput" x="119" y="6" change="channelChangedHandler()"/>
		<s:TextInput id="publishKeyTextInput" x="420" y="8" width="314" textAlign="left"/>
		<s:Label x="47" y="42" text="origin"/>
		<s:Label x="46" y="12" text="channel"/>
		<s:Label x="332" y="44" height="15" text="subscribe key" textAlign="right"/>
		<s:Label x="346" y="12" text="publish key" textAlign="right"/>
		
		<s:BorderContainer id="subConnectionStatus" x="420" y="101" width="53" height="13" backgroundColor="#FC0000">
		</s:BorderContainer>
		<s:Label x="326" y="103" color="#626262" fontStyle="italic" text="SUB Net status"/>
		<s:Label x="48" y="70" text="auth_key"/>
		<s:Label x="37" y="101" text="chiper_key"/>
		<s:TextInput id="authKeyTextInput" x="119" y="64"/>
		<s:TextInput id="chiperKeyTextInput" x="118" y="93"/>
		<s:Group id="pamGroup" x="10" y="609" width="792" height="230">
			<s:Rect id="pamBackground" x="0" y="-68" width="100%" height="216">
				<s:fill>
					<s:SolidColor color="#FF0000"/>
				</s:fill>
			</s:Rect>
			<s:TextInput id="pamChannelTextInput" x="10" y="-38" width="314"/>
			<s:Label x="10" y="-58" text="channel"/>
			<s:Label x="10" y="-8" text="auth_key"/>
			<s:TextInput id="pamAuthKeyTextInput" x="10" y="12" width="314"/>
			<s:Label x="10" y="42" text="secret key"/>
			<s:TextInput id="pamSecretKeyTextInput" x="10" y="62" width="314"/>
			<s:Label x="10" y="92" text="ttl"/>
			<s:TextInput id="pamTtlTextInput" x="10" y="110" width="314"/>
			<s:CheckBox id="pamReadCheckbox" x="365" y="-37" label="Read ?"/>
			<s:CheckBox id="pamWriteCheckbox" x="366" y="-11" label="Write ?"/>
			<s:Button id="grantButton" x="366" y="55" label="Grant" click="grant()"/>
			<s:Button id="revokeButton" x="366" y="84" label="Revoke" click="revoke()"/>
			<s:Button id="auditButton" x="366" y="109" label="Audit" click="audit()"/>
			<s:CheckBox id="pamPnpresCheckbox" x="366" y="16" label="apply to *-pnpres channel too" selected="true"/>
			<s:Label x="560" y="-52" fontSize="20" fontWeight="bold" text="PAM - Access Manager"/>
		</s:Group>
		<s:Scroller x="423" y="142" width="382" height="70">
			<s:RichEditableText id="presenceArea" backgroundColor="#000000" color="#FFFFFF"
								editable="false" fontFamily="Arial" fontSize="10"
								paddingLeft="10" paddingRight="10" paddingTop="10" paddingBottom="10"
								fontWeight="bold"/>
		</s:Scroller>
		<s:Label x="425" y="126" text="presence"/>
		<s:Scroller x="425" y="245" width="382" height="272">
			<s:RichEditableText id="historyArea" backgroundColor="#000000" color="#FFFFFF"
								editable="false" fontFamily="Arial" fontSize="10"
								paddingLeft="10" paddingRight="10" paddingTop="10" paddingBottom="10"/>
		</s:Scroller>
		<s:Label x="426" y="230" text="history"/>
		<s:Button id="clearPresence" x="735" y="124" height="15" label="Clear" click="clearPresenceHandler()"/>
		<s:Button id="clearHistory" x="737" y="227" height="15" label="Clear" click="clearHistoryHandler()"/>
		<s:Button id="historyButton" x="475" y="224" label="History" click="history()"/>
		<s:Scroller x="15" y="245" width="382" height="272">
		<s:RichEditableText id="consoleLog"  backgroundColor="#000000" color="#FFFFFF"
							editable="false" fontFamily="Arial" fontSize="10" fontWeight="bold"
							paddingBottom="10" paddingLeft="10" paddingRight="10" paddingTop="10"/>
		</s:Scroller>
		<s:TextInput id="uuidInput" x="420" y="71" width="229" text="flash_client"/>
		<s:Label x="379" y="77" text="UUID"/>
		<s:CheckBox id="useDefaultUUIDCheckbox" x="653" y="73" label="use default"/>
	</s:BorderContainer>
	</s:VGroup>
</s:Application>
